(* User Declatations *)
structure A = Absyn

fun makeOpExp(e1, expop, e2, p) = 
  A.OpExp {left=e1, oper=expop, right=e2, pos=p}

fun makeIfExp(e1, e2, exop, p) =
  A.IfExp {test=e1, then'=e2, else'=exop option, pos=p}

fun makeAssignExp(v, e, p) =
  A.AssignExp {var=v, exp=e, pos=p}

fun makeArrayExp(sym, e1, e2, p) =
  A.IfExp {typ=sym, exp=e1, exp=e2, pos=p}

(* Parser Declarations *)
%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE | UMINUS

%nonterm 
    program of A.exp
  | decs of A.dec list
  | dec of A.dec
  | tydec of A.dec
  | ty of A.ty
  | tyfields of A.field list
  | extratyfields of A.field list
  | vardec of A.dec
  | fundec of A.dec
  | lvalue of A.var
  | exp of A.exp
  | expSequence of (A.exp * pos) list
  | expSequenceTail of (A.exp * pos) list
  | expRecord of (A.symbol * A.exp * pos)
  | expRecordTail of (A.symbol * A.exp * pos) list
  | recordlist of A.exp list
  | recordlistTail of A.exp list
  | explist of A.exp list
  | explistTail of A.exp list
  | paramlist of A.exp list
  | paramlistTail of A.exp list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

(* Precendence Directives *)
%nonassoc ID
(*all these bind less tightly then operators below*)
%nonassoc DO THEN OF LBRACK
(*ELSE has higher precedence so that it'd shift ELSE when there is one*)
%nonassoc ELSE
(*Assign binds tighter than keywords like THEN, ELSE, etc.*)
%nonassoc ASSIGN

(*precedence order from the book, these operators bind tighter than keywords above*)
%left OR
%left AND
%nonassoc EQ NEQ GT LT GE LE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS


(* Grammar *)
%%
program : exp   (exp)

decs: dec decs (dec::decs)
    | ([])

dec: tydec  (tydec)
   | vardec  (vardec)
   | fundec  (fundec)

tydec: TYPE ID EQ ty  (A.TypeDec{})

ty: ID  ()
  | LBRACE tyfields RBRACE  ()
  | ARRAY OF ID   ()

tyfields:   ()
        | ID COLON ID extratyfields  ()

extratyfields:    ()
             | COMMA ID COLON ID extratyfields  ()

vardec: VAR ID ASSIGN exp   ()                  (* what's the default priority of ASSIGN? *)
      | VAR ID COLON ID ASSIGN exp  ()

fundec: FUNCTION ID LPAREN tyfields RPAREN EQ exp   ()
      | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp  ()

lvalue: ID  ()
      | lvalue DOT ID   ()
      | lvalue LBRACK exp RBRACK  ()

exp: lvalue   (A.VarExp(lvalue))                             (* L-value *)
   | NIL   (A.Nil)                                (* Nil *)
   | LPAREN explist RPAREN   (A.SeqExp(explist))              (* Sequencing / No value *)
   | INT  (A.IntExp(INT))                                 (* Integer literal *)
   | STRING  (A.StringExp(STRING))                              (* String literal *)
   | MINUS exp %prec UMINUS  (makeOpExp(A.IntExp(0), A.MinusOp, exp, MINUSleft))              (* Gives negation the highest precedence *)

   | ID LPAREN paramlist RPAREN   (A.CallExp(Symbol.symbol(ID), paramlist, paramlistleft))         (* Function call *)

                                             (* Arithmetic and Operators *)
   | exp PLUS exp  (makeOpExp(exp1, A.PlusOp, exp2, exp1left))
   | exp MINUS exp  (makeOpExp(exp1, A.MinusOp, exp2, exp1left))
   | exp TIMES exp  (makeOpExp(exp1, A.TimesOp, exp2, exp1left))
   | exp DIVIDE exp  (makeOpExp(exp1, A.DivideOp, exp2, exp1left))
   | exp EQ exp  (makeOpExp(exp1, A.EqOp, exp2, exp1left))
   | exp NEQ exp  (makeOpExp(exp1, A.NeqOp, exp2, exp1left))
   | exp LT exp  (makeOpExp(exp1, A.LtOp, exp2, exp1left))
   | exp LE exp  (makeOpExp(exp1, A.LeOp, exp2, exp1left))
   | exp GT exp  (makeOpExp(exp1, A.GtOp, exp2, exp1left))
   | exp GE exp  (makeOpExp(exp1, A.GeOp, exp2, exp1left))
   | exp AND exp   (makeIfExp(exp1, exp2, A.IntExp(0), exp1left))
   | exp OR exp   (makeIfExp(exp1, A.IntExp(1), exp2, exp1left)) 

   | ID LBRACE recordlist RBRACE   (A.RecordExp {fields=recordList, typ = Symbol.symbol(ID), pos = IDleft})        (* Record creation *)
   | ID LBRACK exp RBRACK OF exp   ()        (* Array creation *)
   | lvalue ASSIGN exp   ()                  (* Assignment *)
   | IF exp THEN exp ELSE exp   ()           (* If-then-else *)
   | IF exp THEN exp   ()                    (* If-then *)
   | WHILE exp DO exp   ()                   (* While *)
   | FOR ID ASSIGN exp TO exp DO exp   ()    (* For *)
   | BREAK   ()                              (* Break *)
   | LET decs IN explist END   ()            (* Let *)

recordlist:   (nil)
          | ID EQ exp recordlistTail   ((Symbol.symbol(ID), exp, expleft)::recordListTail)

recordlistTail:   (nil)
          | COMMA ID EQ exp recordlistTail   ((Symbol.symbol(ID), exp, expleft)::recordListTail)

explist: (nil)
       | exp explistTail ((exp, expleft)::explistTail)

explistTail: (nil)
       | SEMICOLON exp explistTail ((exp, expleft)::explistTail)

paramlist:   (nil)
         | exp paramlistTail   (exp::paramListTail)

paramlistTail:   (nil) 
         | COMMA exp paramlistTail   (exp::paramListTail)